{
    "collab_server" : "",
    "contents" : "#----Load libraries---#\n\nlibrary(purrr)\nlibrary(httr)\nlibrary(readr)\nlibrary(survival)\nlibrary(rstan)\nlibrary(spBayesSurv)\nlibrary(pracma)\nlibrary(assertthat)\nlibrary(cgdsr)\nsuppressMessages(library(dplyr))\nlibrary(ggplot2)\nrequire(ggfortify)\ntheme_set(theme_bw())\nlibrary(VIM)\n\n#---Download Data----#\n\nmycgds = CGDS(\"http://www.cbioportal.org/public-portal/\")\nstudy_list = getCancerStudies(mycgds)\nid_sutdy = getCancerStudies(mycgds)[55,1]\ncase_list = getCaseLists(mycgds, id_sutdy)[2,1]\nclinical_data <-  tbl_df(getClinicalData(mycgds, case_list)) \n\n#---- Data Cleaning ----#\n\nclinical_data <- clinical_data %>% tibble::rownames_to_column(\"sample_id\") \nnames(clinical_data) <- tolower(names(clinical_data)) \n#convert missig values into NA\nconvert_blank_to_na <- function(x) {\n  if(!purrr::is_character(x)){\n    warning('input variate not character - return original')\n    return(x)\n  } else {\n    ifelse(x == '', NA, x)\n  }\n}\nclinical_data <- clinical_data %>%\n  dplyr::mutate_all(funs(convert_blank_to_na))\n\n#--Missing Data ---#\n\nclinical_data %>%\n  VIM::aggr(prop = FALSE, combined = TRUE, numbers = TRUE, sortVars = TRUE, sortCombs = TRUE)\n\nclinical_data %>% \n  filter(is.na(os_status) | os_status == \"\") %>%\n  select(os_months, os_status) %>%\n  glimpse\n\nclinical_data %>% \n  filter(is.na(os_status) | os_status == \"\" |os_months < 0 | is.na(os_months)) %>%\n  select(os_months, os_status) %>%\n  glimpse\n\n#--- Remove Missing Obs ---#\n\nshort_clin_dat <- \n  clinical_data %>% \n  filter(!is.na(os_status) & os_status != \"\" )\n\n#confirm 44 fewer observations\nassertthat::assert_that(nrow(short_clin_dat) == (nrow(clinical_data) - 44))\nclinical_data <- tbl_df(short_clin_dat)\nremove(short_clin_dat)\n\nclinical_data %>%\n  VIM::aggr(prop = FALSE, combined = TRUE, numbers = TRUE, sortVars = TRUE, sortCombs = TRUE)\n\n#--- Distribution event times ---#\n\nclinical_data <- clinical_data %>%\n  arrange(os_months)\n\nclinical_data %>%\n  ggplot(aes(x = os_months,\n             group = os_status,\n             colour = os_status,\n             fill = os_status)) +\n  geom_density(alpha = 0.5)\n\nmle.surv <- survfit(Surv(os_months, os_deceased) ~ 1,\n                    data = clinical_data %>%\n                      mutate(os_deceased = (os_status == \"DECEASED\")))\nrequire(ggfortify)\nggplot2::autoplot(mle.surv, conf.int = F) +\n  ggtitle('KM survival for GGM Cohort')\n\n#----PEM Model ----#\n\ny0 <- c(1,1.1,0.8,0.6, 0.2)\nsfun  <- stepfun(seq(20, 80, by = 20), y0, f = 0)\nplot(sfun,  main = \"Step function of PEM\", xlab = \"time (months)\", ylab = \"baseline hazard ratio\", ylim= c(0, 1.2))\n\nstanfile <- \"'pem_biostan.stan'\"\n#biostan::print_stan_file(stanfile)\n#or open stan file\nif (interactive())\n  file.edit(stanfile)\n\n#---Testing the model on simulated data---#\n\npem_sim_data <- function(n, tau, beta, lambda, X, ...){\n  \n  #format check\n  beta <- as.vector(as.numeric(beta))\n  lambda<- as.vector(as.numeric(lambda))\n  X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))\n\n  #prognostic index\n  mu = exp (X %*% beta )\n  #extract first interval baseline hazard\n  lambda0 <- lambda[1]\n  #compute relative hazard for each interval respect to the first\n  rel_base_risk <- lambda/lambda0\n  rel_risk = lapply(mu, \"*\" , rel_base_risk)\n  #caculate duration\n  dt = diff(tau)\n  assertthat::assert_that(length(dt) == length(lambda))\n  #create a helping matrix\n  LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))\n  LD[lower.tri(LD)] <- 1;\n  #compute log survival\n  logsurv <- log(1-runif(n))\n  #compute log survival for each interval tau\n  lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))\n  t <- (rep(NA,n))\n  #find appropiate time interval\n  t = mapply(function(x, y, z) {\n    for (i in seq_along(lambda)) {\n      t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)\n    }\n    return(t)\n  } , x = lsm, y = rel_risk , z = as.list(logsurv)\n  )\n  \n  sim.data <- data_frame(surv_months = t) %>%\n    mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),\n           surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),\n           id = seq(n), \n           censor_months = rexp(n = n, rate = 1/100))   %>%\n    dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',\n                                     'DECEASED', 'LIVING'\n    ),\n    os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',\n                       surv_months, censor_months\n    )\n    ) %>%   cbind(X) %>%\n    rename(\"continuos\" = \"1\", \"discrete\" = \"2\")\n  \n  return(sim.data)\n}\n\nset.seed(342)\ntest_n = 100\ntest_tau = c(seq(0, 1200, length.out = test_n))\ntest_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)\n# tau = c(seq(0, 300, by = 90), seq(300, 800, by = 100)) #time in months\n# test_baseline <- exp(-4)*rev(seq(0.1, 1, by = 0.1))\nX = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)\ntest_beta = c(0.5, 1)\nsim_data <-  pem_sim_data( beta = test_beta,\n                           X = X,\n                           tau = test_tau,\n                           lambda = test_baseline,\n                           n = test_n\n)\n\n## plot KM curve from simulated data\nsim_data <- \n  sim_data %>%\n  dplyr::mutate(os_deceased = os_status == 'DECEASED')\n\nautoplot(survival::survfit(Surv(os_months, os_deceased) ~ 1,\n                           data = sim_data\n), conf.int = F) + \n  ggtitle('Simulated KM curve')\n#------ long data format ----#\n\n#set the tau interval times\ntau <- sim_data %>% select(os_months) %>% unlist %>% unique %>%\n  sort()\n\nif(tau[1] != 0){\n  tau <- c(0, tau)\n}\n\nlongdata <- survival::survSplit(Surv(time = os_months, event = deceased) ~ . , \n                                cut = tau, data = (sim_data %>%\n                                mutate(deceased = os_status == \"DECEASED\"))) %>%\n                                arrange(id, os_months)\n\n\n#create time point id\nlongdata <- longdata %>%\n  group_by(id) %>%\n  mutate(t = seq(n())) %>%\n  ungroup()\n\n#----Generate stan data----#\nM = length(test_beta)\ngen_stan_data <- function(data){\n  stan_data <- list(\n    N = nrow(data),\n    S = length(unique(longdata$t)),\n    \"T\" = dplyr::n_distinct(data$t),\n    s = array(as.integer(data$id)),\n    t = data$t,\n    M=M,\n    event = as.integer(data$deceased),\n    obs_t = data$os_months,\n    x = array(matrix(c(data$continuos, data$discrete), ncol=M), dim=c(nrow(data), M))\n  )\n}\n\n#---Set initial values---#\ngen_inits <- function() {\n  list(\n    beta = rcauchy(M, location = 0 , scale = 2),\n    baseline = rgamma(n = length(diff(tau)), shape = 1, scale = 0.001)\n  )\n}\n\n\n#---Set initial values---#\ngen_inits <- function() {\n  list(\n    beta = rcauchy(M, location = 0 , scale = 2),\n    c = abs(rcauchy(n = 1, scale = 0.001)),\n    r = abs(rcauchy(n = 1, scale = 0.1)),\n    baseline = rgamma(n = length(diff(tau)), shape = 0.1 * mean(diff(tau)), scale = 0.001)\n    \n  )\n}\n\n#-----Run Stan-------#\nnChain <- 4\nstanfile <- 'pem_survival_model.stan'\nrstan_options(auto_write = TRUE)\nsimulated_fit <- stan(stanfile,\n                      data = gen_stan_data(longdata),\n                      init = gen_inits,\n                      iter = 1000,\n                      cores = min(nChain, parallel::detectCores()),\n                      seed = 7327,\n                      chains = nChain,\n                      pars = c(\"beta\", \"baseline\", \"lp__\")\n                      #control = list(adapt_delta = 0.99)\n)\n\n#----Convergence review -----#\nprint(simulated_fit)\npairs(simulated_fit, pars = c(\"lp__\", \"beta\"), las = 1)\n\nrstan::traceplot(simulated_fit, 'lp__')\nrstan::traceplot(simulated_fit, 'beta')\n  \n# if (interactive())\n#   shinystan::launch_shinystan(simulated_fit)\n  \n  \n#---Review posterior distribution of beta parameters--#\n\n\npp_beta1 <- rstan::extract(simulated_fit,'beta[1]')$beta\npp_beta2 <- rstan::extract(simulated_fit,'beta[2]')$beta\n\nggplot(data.frame(beta1 = pp_beta1, beta2 = pp_beta2)) + \n  geom_density(aes(x = beta1)) + \n  geom_vline(aes(xintercept = test_beta[1]), colour = 'red') +\n  ggtitle('Posterior distribution of beta 1\\nshowing true value in red')\n\nggplot(data.frame(beta1 = pp_beta1, beta2 = pp_beta2)) + \n  geom_density(aes(x = beta2)) + \n  geom_vline(aes(xintercept = test_beta[2]), colour = 'red') +\n  ggtitle('Posterior distribution of beta 2\\nshowing true value in red')\n\nggplot(data.frame(beta1 = pp_beta1, beta2 = pp_beta2)) + \n  geom_density2d(aes(x = beta1, y = beta2)) +\n  geom_point(aes(x = test_beta[1], y = test_beta[2]), colour = 'red', size = 2) +\n  ggtitle('Posterior distributions of beta\\nshowing true parameter values in red')\n\n#Compute probability of seeing a value beta1 >=1.5\n\nmean(pp_beta1 >= test_beta[1])\n\n#Compute probability of seeing a value beta1 >=-2\n\nmean(pp_beta2 >= test_beta[2])\n#Joint probability\n\n\nmean(pp_beta1 >= test_beta[1] & pp_beta2 >= test_beta[2])\n\n#---Posterior predictive checks---#\n\npp_beta_bg <- as.data.frame.array(rstan::extract(simulated_fit,pars = 'beta', permuted = TRUE)$beta) \npp_lambda <- as.data.frame.array(rstan::extract(simulated_fit,pars = 'baseline', permuted = TRUE)$baseline)\n\n# create list\npp_beta_bg <-  split(pp_beta_bg, seq(nrow(pp_beta_bg)))\npp_lambda <-  split(pp_lambda, seq(nrow(pp_lambda)))\n\npp_newdata <- \n  purrr::pmap(list(pp_beta_bg, pp_lambda),\n              function(pp_beta, pp_lambda) {pem_sim_data(lambda = pp_lambda, \n                                           beta = pp_beta,\n                                           tau = tau,\n                                           n = test_n,\n                                           X = X)\n              } )\n\nggplot(pp_newdata %>%\n         dplyr::bind_rows() %>%\n         dplyr::mutate(type = 'posterior predicted values') %>%\n         bind_rows(sim_data %>% dplyr::mutate(type = 'actual data'))\n       , aes(x = os_months, group = os_status, colour = os_status, fill = os_status)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~type, ncol = 1)\n\n\n#--Summarise posterior predictive values\n\n## ----sim-pp-survdata-----------------------------------------------------\n## cumulative survival rate for each posterior draw\npp_survdata <-\n  pp_newdata %>%\n  purrr::map(~ dplyr::mutate(., os_deceased = os_status == 'DECEASED')) %>%\n  purrr::map(~ survival::survfit(Surv(os_months, os_deceased) ~ 1, data = .)) %>%\n  purrr::map(fortify)\n\n## summarize cum survival for each unit time (month), summarized at 95% confidence interval\npp_survdata_agg <- \n  pp_survdata %>%\n  purrr::map(~ dplyr::mutate(., time_group = floor(time))) %>%\n  dplyr::bind_rows() %>%\n  dplyr::group_by(time_group) %>%\n  dplyr::summarize(surv_mean = mean(surv)\n                   , surv_p50 = median(surv)\n                   , surv_lower = quantile(surv, probs = 0.025)\n                   , surv_upper = quantile(surv, probs = 0.975)\n  ) %>%\n  dplyr::ungroup()\n\n## km-curve for test data \ntest_data_kmcurve <- \n  fortify(\n    survival::survfit(\n      Surv(os_months, os_deceased) ~ 1, \n      data = sim_data %>% \n        dplyr::mutate(os_deceased = os_status == 'DECEASED')\n    )) %>%\n  dplyr::mutate(lower = surv, upper = surv)\n\nggplot(pp_survdata_agg %>%\n         dplyr::mutate(type = 'posterior predicted values') %>%\n         dplyr::rename(surv = surv_p50, lower = surv_lower, upper = surv_upper, time = time_group) %>%\n         bind_rows(test_data_kmcurve %>% dplyr::mutate(type = 'actual data')),\n       aes(x = time, group = type, linetype = type)) + \n  geom_line(aes(y = surv, colour = type)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +\n  xlim(c(0, 250))\n\n#----Fitting Model to TCGA Glioblastome data----#\n\n#--- Update gen stan data function to include covariates ---#\n\n#--- This function will take a formula object as input --- #\n\ngen_stan_data <- function(data, formula = as.formula(~1)) {\n  if(!inherits(formula, 'formula'))\n    formula <- as.formula(formula)\n  \n  data <- tibble::rownames_to_column(data, var = \"id\")\n  \n  tau <- data %>% \n    filter(os_status == \"DECEASED\") %>%\n    select(os_months) %>% \n    unlist() %>%\n    unique() %>%\n    sort()\n  \n  if(tau[1] == 0){\n    tau <- c(tau, 12*10^3)\n  } else {\n    tau <- c(0, tau, 12*10^3)\n  }\n  \n  longdata <- tbl_df(survival::survSplit(Surv(time = os_months, event = deceased) ~ . , \n                                  cut = tau,\n                                  data = (data %>%\n                                          mutate(deceased = os_status == \"DECEASED\"))) %>%\n                                          arrange(id, os_months))\n  \n  #create time point id\n  longdata <- longdata %>%\n    group_by(id) %>%\n    mutate(t = seq(n())) \n  \n  X_bg <- longdata %>%\n    model.matrix(formula, data = .)\n  \n  M_bg <- ncol(X_bg)\n  \n  if (M_bg > 1){\n    if(\"(Intercept)\" %in% colnames(X_bg))\n      X_bg <- array(X_bg[,-1], dim = c(nrow(longdata), M_bg - 1))\n    M_bg <- ncol(X_bg)\n  }\n  \n  \n  stan_data <- list(\n    N = nrow(longdata),\n    S = dplyr::n_distinct(longdata$id),\n    \"T\" = dplyr::n_distinct(longdata$t),\n    s = as.numeric(longdata$id),\n    t = longdata$t,\n    M = M_bg,\n    event = longdata$deceased,\n    obs_t = longdata$os_months,\n    x = X_bg\n  )\n}\n\n\n#---Set initial values---#\ntau <- clinical_data %>% filter(os_status == \"DECEASED\") %>% select(os_months) %>% unlist %>% unique %>%\n  sort()\n\nif(tau[1] == 0){\n  tau <- c(tau, 12*10^3)\n} else {\n  tau <- c(0, tau, 12*10^3)\n}\n\nM = 2\ngen_inits <- function() {\n  list(\n    beta_bg_raw = rnorm(M),\n    tau_s_bg_raw = 0.1*abs(rnorm(1)),\n    tau_bg_raw = abs(rnorm(M)),\n    c_raw = abs(rnorm(1)),\n    r_raw = abs(rnorm(1)),\n    baseline = rgamma(n = n_distinct(diff(tau)), shape = exp(3), scale = 0.1)\n    \n  )\n}\n\n\n#-----Run Stan-------#\nnChain <- 1\nstanfile <- 'pem_bg.stan'\nrstan_options(auto_write = TRUE)\nsimulated_fit <- stan(stanfile,\n                      data = gen_stan_data(clinical_data, '~ I(sex == \"Male\") + age'),\n                      init = gen_inits,\n                      iter = 10,\n                      cores = min(nChain, parallel::detectCores()),\n                      seed = 7327,\n                      chains = nChain,\n                      control = list(adapt_delta = 0.99, max_treedepth = 15)\n)\n\n\n###########\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npp_predict_surv <- function(pp_beta, pp_lambda, n, tau, X,\n                            level = 0.9, \n                            plot = F, data = NULL,\n                            sim_data_fun = pem_sim_data\n) {\n  pp_newdata <- \n    purrr::pmap(list(pp_beta, pp_lambda),\n                function(a, b) {pem_sim_data(lambda = a, \n                                             beta = b,\n                                             tau = tau,\n                                             n = n,\n                                             X = X)\n                } )\n  \n  pp_survdata <-\n    pp_newdata %>%\n    purrr::map(~ dplyr::mutate(., os_deceased = os_status == 'DECEASED')) %>%\n    purrr::map(~ survival::survfit(Surv(os_months, os_deceased) ~ 1, data = .)) %>%\n    purrr::map(fortify)\n  \n  ## compute quantiles given level \n  lower_p <- 0 + ((1 - level)/2)\n  upper_p <- 1 - ((1 - level)/2)\n  \n  pp_survdata_agg <- \n    pp_survdata %>%\n    purrr::map(~ dplyr::mutate(.,\n                               time_group = floor(time))) %>%\n    dplyr::bind_rows() %>%\n    dplyr::group_by(time_group) %>%\n    dplyr::summarize(surv_mean = mean(surv)\n                     , surv_p50 = median(surv)\n                     , surv_lower = quantile(surv,\n                                             probs = lower_p)\n                     , surv_upper = quantile(surv,\n                                             probs = upper_p)\n    ) %>%\n    dplyr::ungroup()\n  \n  if (plot == FALSE) {\n    return(pp_survdata_agg)\n  } \n  \n  ggplot_data <- pp_survdata_agg %>%\n    dplyr::mutate(type = 'posterior predicted values') %>%\n    dplyr::rename(surv = surv_p50,\n                  lower = surv_lower,\n                  upper = surv_upper, time = time_group)\n  \n  if (!is.null(data))\n    ggplot_data <- \n    ggplot_data %>% \n    bind_rows(\n      fortify(\n        survival::survfit(\n          Surv(os_months, os_deceased) ~ 1, \n          data = data %>% \n            dplyr::mutate(\n              os_deceased = os_status == 'DECEASED')\n        )) %>%\n        dplyr::mutate(lower = surv,\n                      upper = surv, type = 'actual data')\n    )\n  \n  pl <- ggplot(ggplot_data,\n               aes(x = time, group = type, linetype = type)) + \n    geom_line(aes(y = surv, colour = type)) +\n    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2)\n  \n  pl \n}\n\n\n\n",
    "created" : 1518774049990.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4204711242",
    "id" : "A08B069B",
    "lastKnownWriteTime" : 1518686717,
    "last_content_update" : 1518686717,
    "path" : "C:/RFactory/bayesyoungmeet/pem_example.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}